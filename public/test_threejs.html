<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>Day 355</title>
        <link rel="stylesheet" href="stylesheets/test.css" />
        <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" />
        <style>
            body {
                background: rgb(0, 0, 0);
            }

            .fill-width {
                z-index: 1;
            }

            .canvas-container > canvas {
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="container" class="fill-width"></div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min.js" charset="utf-8"></script>

        <script type="x-shader/x-vertex" id="vertexShader2">

            //
            // GLSL textureless classic 3D noise "cnoise",
            // with an RSL-style periodic variant "pnoise".
            // Author:  Stefan Gustavson (stefan.gustavson@liu.se)
            // Version: 2011-10-11
            //
            // Many thanks to Ian McEwan of Ashima Arts for the
            // ideas for permutation and gradient selection.
            //
            // Copyright (c) 2011 Stefan Gustavson. All rights reserved.
            // Distributed under the MIT license. See LICENSE file.
            // https://github.com/ashima/webgl-noise
            //

            vec3 mod289(vec3 x)
            {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 mod289(vec4 x)
            {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 permute(vec4 x)
            {
              return mod289(((x*34.0)+1.0)*x);
            }

            vec4 taylorInvSqrt(vec4 r)
            {
              return 1.79284291400159 - 0.85373472095314 * r;
            }

            vec3 fade(vec3 t) {
              return t*t*t*(t*(t*6.0-15.0)+10.0);
            }

            // Classic Perlin noise
            float cnoise(vec3 P) {
                vec3 Pi0 = floor(P); // Integer part for indexing
                vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
                Pi0 = mod289(Pi0);
                Pi1 = mod289(Pi1);
                vec3 Pf0 = fract(P); // Fractional part for interpolation
                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz;
                vec4 iz1 = Pi1.zzzz;

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 * (1.0 / 7.0);
                vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 * (1.0 / 7.0);
                vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x;
                g010 *= norm0.y;
                g100 *= norm0.z;
                g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x;
                g011 *= norm1.y;
                g101 *= norm1.z;
                g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return n_xyz;
            }

            // Classic Perlin noise, periodic variant
            float pnoise(vec3 P, vec3 rep) {
                vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
                vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
                Pi0 = mod289(Pi0);
                Pi1 = mod289(Pi1);
                vec3 Pf0 = fract(P); // Fractional part for interpolation
                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz;
                vec4 iz1 = Pi1.zzzz;

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 * (1.0 / 7.0);
                vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 * (1.0 / 7.0);
                vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x;
                g010 *= norm0.y;
                g100 *= norm0.z;
                g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x;
                g011 *= norm1.y;
                g101 *= norm1.z;
                g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return 2.2 * n_xyz;
            }

            float stripes( float x, float f) {
            	float PI = 3.14159265358979323846264;
            	float t = .5 + .5 * sin( f * 2.0 * PI * x);
            	return t * t - .5;
            }

            float turbulence( vec3 p ) {
            	float w = 100.0;
            	float t = -.5;
            	for (float f = 1.0 ; f <= 10.0 ; f++ ){
            		float power = pow( 2.0, f );
            		t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
            	}
            	return t;
            }

            float f( vec3 p ) {
            	return pnoise( vec3( p ), vec3( 10.0, 10.0, 10.0 ) );
            	return pnoise( 8.0 * vec3( p ), vec3( 10.0, 10.0, 10.0 ) );
            }

            float fround( float value ) {
            	return floor( value + 0.5 );
            }

            vec3 v3round( vec3 value ) {
            	return vec3( fround( value.x ), fround( value.y ), fround( value.z ) );
            }
            uniform vec2 u_mousePosition;
            uniform float u_time;
            uniform float u_timeOffset;

            varying vec2 vUv;
            varying vec3 vPos;
            varying float vDistortion1;
            varying float vDistortion2;
            varying float vDistortion3;

            void main() {
                // vDistortion = pnoise(normal + (u_time * 0.2 + u_timeOffset), vec3(10.));
                // vUv = uv;
                //
                // vec3 pos = position;
                // pos.xz += vDistortion * 2.;
                // pos.yz += vDistortion * 2.;
                //
                // gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                vUv = uv;
                vDistortion1 = pnoise(normal + u_time * 0.2 + u_timeOffset, vec3(10.));
                vDistortion2 = pnoise(normal + u_time * 0.1 + u_timeOffset + 5., vec3(10.));
                vDistortion3 = pnoise(normal * 1.2 + u_time * 0.3 + u_timeOffset - 5., vec3(10.));

                vPos = position;
                vPos.xz += vDistortion1 * 2.;
                vPos.yz += vDistortion1 * 2.;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(vPos, 1.0);
            }
        </script>
        <script type="x-shader/x-fragment" id="fragmentShader2">
            vec3 rgb(float r, float g, float b) {
                return vec3(r / 255., g / 255., b / 255.);
            }

            vec3 rgb(float c) {
                return vec3(c / 255., c / 255., c / 255.);
            }
            #ifndef TAU
            #define TAU 6.283185307179586
            #endif

            uniform vec3 u_color1;
            uniform vec3 u_color2;
            uniform vec3 u_color3;
            uniform vec3 u_color4;
            uniform float u_radius;

            varying vec2 vUv;
            varying vec3 vPos;
            varying float vDistortion1;
            varying float vDistortion2;
            varying float vDistortion3;

            void main() {
                vec3 c1 = rgb(u_color1.r, u_color1.g, u_color1.b);
                vec3 c2 = rgb(u_color2.r, u_color2.g, u_color2.b);
                vec3 c3 = rgb(u_color3.r, u_color3.g, u_color3.b);
                vec3 c4 = rgb(u_color4.r, u_color4.g, u_color4.b);
                vec3 color = c1;

                color = mix(color, c2, vDistortion1);
                color = mix(color, c3, vDistortion2);
                color = mix(color, c4, vDistortion3);

                float dist = distance(vPos.xy, vec2(0.));
                float area = smoothstep((u_radius * 0.6) - (u_radius * 0.6) / 5., (u_radius * 0.6), dist);

                vec2 uv = vUv;
                uv.x = 1. - (cos(uv.x * TAU) + 1.) / 2.;

                // color = mix(color, vec3(0.), area * 1.);

                gl_FragColor = vec4(color, 1.);
            }
        </script>

        <script type="x-shader/x-vertex" id="vertexShader1">

            //
            // GLSL textureless classic 3D noise "cnoise",
            // with an RSL-style periodic variant "pnoise".
            // Author:  Stefan Gustavson (stefan.gustavson@liu.se)
            // Version: 2011-10-11
            //
            // Many thanks to Ian McEwan of Ashima Arts for the
            // ideas for permutation and gradient selection.
            //
            // Copyright (c) 2011 Stefan Gustavson. All rights reserved.
            // Distributed under the MIT license. See LICENSE file.
            // https://github.com/ashima/webgl-noise
            //

            vec3 mod289(vec3 x)
            {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 mod289(vec4 x)
            {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 permute(vec4 x)
            {
              return mod289(((x*34.0)+1.0)*x);
            }

            vec4 taylorInvSqrt(vec4 r)
            {
              return 1.79284291400159 - 0.85373472095314 * r;
            }

            vec3 fade(vec3 t) {
              return t*t*t*(t*(t*6.0-15.0)+10.0);
            }

            // Classic Perlin noise
            float cnoise(vec3 P) {
                vec3 Pi0 = floor(P); // Integer part for indexing
                vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
                Pi0 = mod289(Pi0);
                Pi1 = mod289(Pi1);
                vec3 Pf0 = fract(P); // Fractional part for interpolation
                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz;
                vec4 iz1 = Pi1.zzzz;

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 * (1.0 / 7.0);
                vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 * (1.0 / 7.0);
                vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x;
                g010 *= norm0.y;
                g100 *= norm0.z;
                g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x;
                g011 *= norm1.y;
                g101 *= norm1.z;
                g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return n_xyz;
            }

            // Classic Perlin noise, periodic variant
            float pnoise(vec3 P, vec3 rep) {
                vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
                vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
                Pi0 = mod289(Pi0);
                Pi1 = mod289(Pi1);
                vec3 Pf0 = fract(P); // Fractional part for interpolation
                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz;
                vec4 iz1 = Pi1.zzzz;

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 * (1.0 / 7.0);
                vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 * (1.0 / 7.0);
                vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x;
                g010 *= norm0.y;
                g100 *= norm0.z;
                g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x;
                g011 *= norm1.y;
                g101 *= norm1.z;
                g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return 2.2 * n_xyz;
            }

            float stripes( float x, float f) {
            	float PI = 3.14159265358979323846264;
            	float t = .5 + .5 * sin( f * 2.0 * PI * x);
            	return t * t - .5;
            }

            float turbulence( vec3 p ) {
            	float w = 100.0;
            	float t = -.5;
            	for (float f = 1.0 ; f <= 10.0 ; f++ ){
            		float power = pow( 2.0, f );
            		t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
            	}
            	return t;
            }

            float f( vec3 p ) {
            	return pnoise( vec3( p ), vec3( 10.0, 10.0, 10.0 ) );
            	return pnoise( 8.0 * vec3( p ), vec3( 10.0, 10.0, 10.0 ) );
            }

            float fround( float value ) {
            	return floor( value + 0.5 );
            }

            vec3 v3round( vec3 value ) {
            	return vec3( fround( value.x ), fround( value.y ), fround( value.z ) );
            }

            uniform float u_time;
            uniform float u_timeOffset;

            varying float vDistortion;
            varying vec2 vUv;

            void main() {
                vDistortion = pnoise(normal + (u_time * 0.2 + u_timeOffset), vec3(10.));
                vUv = uv;

                vec3 pos = position;
                pos.xz += vDistortion * 2.;
                pos.yz += vDistortion * 2.;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        </script>
        <script type="x-shader/x-fragment" id="fragmentShader1">
            vec3 rgb(float r, float g, float b) {
                return vec3(r / 255., g / 255., b / 255.);
            }

            vec3 rgb(float c) {
                return vec3(c / 255., c / 255., c / 255.);
            }
            float lighten(float base, float blend) {
            	return max(blend,base);
            }

            vec3 lighten(vec3 base, vec3 blend) {
            	return vec3(lighten(base.r,blend.r),lighten(base.g,blend.g),lighten(base.b,blend.b));
            }

            vec3 lighten(vec3 base, vec3 blend, float opacity) {
            	return (lighten(base, blend) * opacity + base * (1.0 - opacity));
            }

            uniform vec3 u_bg;
            uniform vec3 u_color1;
            uniform vec3 u_color2;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_time;

            varying float vDistortion;
            varying vec2 vUv;

            vec2 random2( vec2 p ) {
                return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
            }

            void main() {
                vec2 st = vUv;
                vec3 bg = rgb(u_bg.r, u_bg.g, u_bg.b);
                vec3 c1 = rgb(u_color1.r, u_color1.g, u_color1.b);
                vec3 c2 = rgb(u_color2.r, u_color2.g, u_color2.b);
                vec3 color = bg;

                st *= 7.;
                vec2 i_st = floor(st);
                vec2 f_st = fract(st);

                float m_dist = 50.;
                float s_dist = 50.;
                vec2 m_point;

                for (int j=-1; j<=1; j++ ) {
                    for (int i=-1; i<=1; i++ ) {
                        vec2 neighbor = vec2(float(i), float(j));
                        vec2 point = random2(i_st + neighbor);
                        point = 0.5 + 0.5 * sin(u_time * 0.5 + 6.2831 * point);
                        vec2 diff = neighbor + point - f_st;
                        vec2 diff2 = neighbor + point - f_st * 1.04;
                        float dist = length(diff);
                        float dist2 = length(diff2);

                        if( dist < m_dist ) {
                            m_dist = dist;
                            s_dist = dist2;
                            m_point = point;
                        }
                    }
                }

                color = mix(
                    color,
                    c1,
                    dot(m_point, vec2(0.3, 0.6))
                );

                color = mix(
                    color,
                    c2,
                    m_dist * s_dist
                );

                color = mix(
                    color,
                    c1,
                    vDistortion * 0.5
                );

                color *= 1.8;
                color.r -= 0.7;
                color.b += 0.3;

                gl_FragColor = vec4(color,1.0);
            }
        </script>

        <script>
            var createHeroInteractive = function($container) {
                'use strict'
                // prettier-ignore
                var renderer, scene, camera, pixelRatio = Math.min(window.devicePixelRatio, 2),
	geometry1, material1, mesh1,
	fov = 45;

                var mousePosition = {
                    x: 0.5,
                    y: 0.5,
                    drag: 0
                }
                var v2MousePosition = new THREE.Vector2(mousePosition.x, mousePosition.y)
                var v3MouseDrag = new THREE.Vector3(mousePosition.x, mousePosition.y, mousePosition.drag)

                var start = Date.now()
                var fixedTime = 0,
                    timeOffset = 0,
                    dynamicTime = 0

                var w, h, isMobile

                var camX = 0
                var camY = 0

                var isFocused = true,
                    isInited = false,
                    inViewport = false
                window.addEventListener('blur', function() {
                    isFocused = false
                })
                window.addEventListener('focus', function() {
                    isFocused = true
                    if (isInited) {
                        render()
                    }
                })

                function updateSize() {
                    w = $container.offsetWidth
                    h = $container.offsetHeight
                    isMobile = w < 800
                }

                init()

                function init() {
                    updateSize()

                    scene = new THREE.Scene()

                    camera = new THREE.PerspectiveCamera(fov, w / h, 1, 500)
                    camera.position.z = isMobile ? 200 : 150

                    scene.add(camera)

                    geometry1 = new THREE.IcosahedronGeometry(40, 3)
                    material1 = new THREE.ShaderMaterial({
                        uniforms: {
                            u_color1: { type: 'v3', value: new THREE.Vector3(255, 0, 255) },
                            u_color2: { type: 'v3', value: new THREE.Vector3(0, 186, 240) },
                            u_color3: { type: 'v3', value: new THREE.Vector3(0, 244, 255) },
                            u_color4: { type: 'v3', value: new THREE.Vector3(0, 244, 255) },
                            u_time: { type: 'f', value: 0 },
                            u_timeOffset: { type: 'f', value: 4.6 },
                            u_dimensions: {
                                type: 'v2',
                                value: new THREE.Vector2(w * pixelRatio, h * pixelRatio)
                            },
                            u_radius: { type: 'f', value: 40 }
                        },
                        fragmentShader: document.querySelector('#fragmentShader2').textContent,
                        vertexShader: document.querySelector('#vertexShader2').textContent
                    })
                    var envMap = new THREE.TextureLoader().load(
                        'https://272507.selcdn.ru/evys_api_videos/glass_texture.png'
                    )
                    envMap.mapping = THREE.SphericalReflectionMapping
                    material1.envMap = envMap
                    mesh1 = new THREE.Mesh(geometry1, material1)
                    mesh1.position.set(0, 0, 0)
                    mesh1.scale.multiplyScalar(1.0)
                    mesh1.rotation.x = 0.0
                    mesh1.rotation.y = 0.0
                    mesh1.rotation.z = 1.6
                    scene.add(mesh1)

                    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false })
                    renderer.setPixelRatio(pixelRatio)
                    renderer.setSize(w, h)
                    renderer.setClearColor(new THREE.Color('rgb(0,0,0)'))

                    $container.appendChild(renderer.domElement)

                    window.addEventListener('resize', handleResize)
                    if ('ontouchstart' in window) {
                        // document.body.addEventListener('touchmove', handleTouchMove);
                    } else {
                        // document.body.addEventListener('mousemove', handleMouseMove);
                        document.body.addEventListener('mousedown', handleMouseDown)
                        document.body.addEventListener('mouseup', handleMouseUp)
                    }

                    isInited = true
                    render()
                }

                function handleResize() {
                    updateSize()
                    renderer.setSize(w, h)
                    camera.aspect = w / h

                    var v2WH = new THREE.Vector2(w, h)
                    camera.updateProjectionMatrix()
                }

                function handleTouchMove(e) {
                    var touch = e.touches[0]
                    mousePosition.x = touch.pageX / w
                    mousePosition.y = touch.pageY / h
                }

                function handleMouseMove(e) {
                    mousePosition.x = e.pageX / w
                    mousePosition.y = e.pageY / h
                }

                function handleMouseDown(e) {
                    mousePosition.drag = 1
                }

                function handleMouseUp(e) {
                    mousePosition.drag = 0
                }

                function render(timestamp) {
                    if (isFocused) {
                        camX = ((mousePosition.x - 0.5) * (isMobile ? 120 : 80) - camera.position.x) * 0.05
                        camY = ((mousePosition.y - 0.5) * (isMobile ? 80 : 40) - camera.position.y) * 0.05

                        fixedTime = 0.0003 * (Date.now() - start)

                        timeOffset += (Math.abs(camX) + Math.abs(camY)) / (isMobile ? 50 : 20)
                        dynamicTime = fixedTime + timeOffset
                        material1.uniforms.u_time.value = dynamicTime

                        camera.position.x += camX
                        camera.position.y += camY
                        camera.position.z += camY
                        camera.lookAt(scene.position)

                        renderer.gammaInput = true
                        renderer.gammaOutput = true

                        renderer.render(scene, camera)
                        requestAnimationFrame(render)
                    }
                }
            }
            createHeroInteractive(document.getElementById('container'))
        </script>
    </body>
</html>
