<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>Day 355</title>
        <link rel="stylesheet" href="stylesheets/test.css" />
        <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet" />
        <style>
            body {
                background: rgb(0, 0, 0);
            }

            .fill-width {
                z-index: 1;
            }

            .canvas-container > canvas {
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="container" class="fill-width"></div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/104/three.min.js" charset="utf-8"></script>
        <script src="javascripts/Lensflare.js"></script>
        <script src="javascripts/FlyControls.js"></script>

        <script type="x-shader/x-vertex" id="vertexShader2">

            //
            // GLSL textureless classic 3D noise "cnoise",
            // with an RSL-style periodic variant "pnoise".
            // Author:  Stefan Gustavson (stefan.gustavson@liu.se)
            // Version: 2011-10-11
            //
            // Many thanks to Ian McEwan of Ashima Arts for the
            // ideas for permutation and gradient selection.
            //
            // Copyright (c) 2011 Stefan Gustavson. All rights reserved.
            // Distributed under the MIT license. See LICENSE file.
            // https://github.com/ashima/webgl-noise
            //

            vec3 mod289(vec3 x)
            {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 mod289(vec4 x)
            {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
            }

            vec4 permute(vec4 x)
            {
              return mod289(((x*34.0)+1.0)*x);
            }

            vec4 taylorInvSqrt(vec4 r)
            {
              return 1.79284291400159 - 0.85373472095314 * r;
            }

            vec3 fade(vec3 t) {
              return t*t*t*(t*(t*6.0-15.0)+10.0);
            }

            // Classic Perlin noise
            float cnoise(vec3 P) {
                vec3 Pi0 = floor(P); // Integer part for indexing
                vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
                Pi0 = mod289(Pi0);
                Pi1 = mod289(Pi1);
                vec3 Pf0 = fract(P); // Fractional part for interpolation
                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz;
                vec4 iz1 = Pi1.zzzz;

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 * (1.0 / 7.0);
                vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 * (1.0 / 7.0);
                vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x;
                g010 *= norm0.y;
                g100 *= norm0.z;
                g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x;
                g011 *= norm1.y;
                g101 *= norm1.z;
                g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return n_xyz;
            }

            // Classic Perlin noise, periodic variant
            float pnoise(vec3 P, vec3 rep) {
                vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
                vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
                Pi0 = mod289(Pi0);
                Pi1 = mod289(Pi1);
                vec3 Pf0 = fract(P); // Fractional part for interpolation
                vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
                vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
                vec4 iy = vec4(Pi0.yy, Pi1.yy);
                vec4 iz0 = Pi0.zzzz;
                vec4 iz1 = Pi1.zzzz;

                vec4 ixy = permute(permute(ix) + iy);
                vec4 ixy0 = permute(ixy + iz0);
                vec4 ixy1 = permute(ixy + iz1);

                vec4 gx0 = ixy0 * (1.0 / 7.0);
                vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
                gx0 = fract(gx0);
                vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
                vec4 sz0 = step(gz0, vec4(0.0));
                gx0 -= sz0 * (step(0.0, gx0) - 0.5);
                gy0 -= sz0 * (step(0.0, gy0) - 0.5);

                vec4 gx1 = ixy1 * (1.0 / 7.0);
                vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
                gx1 = fract(gx1);
                vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
                vec4 sz1 = step(gz1, vec4(0.0));
                gx1 -= sz1 * (step(0.0, gx1) - 0.5);
                gy1 -= sz1 * (step(0.0, gy1) - 0.5);

                vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
                vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
                vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
                vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
                vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
                vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
                vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
                vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

                vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
                g000 *= norm0.x;
                g010 *= norm0.y;
                g100 *= norm0.z;
                g110 *= norm0.w;
                vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
                g001 *= norm1.x;
                g011 *= norm1.y;
                g101 *= norm1.z;
                g111 *= norm1.w;

                float n000 = dot(g000, Pf0);
                float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
                float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
                float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
                float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
                float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
                float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
                float n111 = dot(g111, Pf1);

                vec3 fade_xyz = fade(Pf0);
                vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
                vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
                float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
                return 2.2 * n_xyz;
            }

            float stripes( float x, float f) {
            	float PI = 3.14159265358979323846264;
            	float t = .5 + .5 * sin( f * 2.0 * PI * x);
            	return t * t - .5;
            }

            float turbulence( vec3 p ) {
            	float w = 100.0;
            	float t = -.5;
            	for (float f = 1.0 ; f <= 10.0 ; f++ ){
            		float power = pow( 2.0, f );
            		t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
            	}
            	return t;
            }

            float f( vec3 p ) {
            	return pnoise( vec3( p ), vec3( 10.0, 10.0, 10.0 ) );
            	return pnoise( 8.0 * vec3( p ), vec3( 10.0, 10.0, 10.0 ) );
            }

            float fround( float value ) {
            	return floor( value + 0.5 );
            }

            vec3 v3round( vec3 value ) {
            	return vec3( fround( value.x ), fround( value.y ), fround( value.z ) );
            }
            uniform vec2 u_mousePosition;
            uniform float u_time;
            uniform float u_timeOffset;

            varying vec2 vUv;
            varying vec3 vPos;
            varying vec3 vNormal;
            varying float vDistortion1;
            varying float vDistortion2;

            void main() {
                vUv = uv;
                vDistortion1 = pnoise(normal + u_time * 0.2 + u_timeOffset, vec3(10.));
                vDistortion2 = pnoise(normal + u_time * 0.1 + u_timeOffset + 5., vec3(10.));

                vPos = position;

                vNormal = normal;
                vPos.xz += vDistortion1 * 2.;
                vPos.yz += vDistortion1 * 2.;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(vPos, 1.0);
            }
        </script>
        <script type="x-shader/x-fragment" id="fragmentShader2">
            vec3 rgb(float r, float g, float b) {
                return vec3(r / 255., g / 255., b / 255.);
            }

            vec3 rgb(float c) {
                return vec3(c / 255., c / 255., c / 255.);
            }

            struct PointLight {
              vec3 color;
              vec3 position; // light position, in camera coordinates
              float distance; // used for attenuation purposes. Since
                              // we're writing our own shader, it can
                              // really be anything we want (as long as
                              // we assign it to our light in its
                              // "distance" field
            };

            uniform PointLight pointLights[NUM_POINT_LIGHTS];
            #ifndef TAU
            #define TAU 6.283185307179586
            #endif

            uniform vec3 u_color1;
            uniform vec3 u_color2;
            uniform vec3 u_color3;
            uniform vec3 u_color4;
            uniform float u_radius;
            uniform float lightIntensity;

            varying vec2 vUv;
            varying vec3 vPos;
            varying vec3 vNormal;
            varying float vDistortion1;
            varying float vDistortion2;

            void main() {
                vec4 addedLights = vec4(0.0,0.0,0.0,1.0);
                for(int l = 0; l < NUM_POINT_LIGHTS; l++) {
                    vec3 lightDirection = normalize(vPos - pointLights[l].position);
                    addedLights.rgb += clamp(dot(-lightDirection, vNormal), 0.0, 1.0) * pointLights[l].color * lightIntensity;
                }
                vec3 c1 = rgb(u_color1.r, u_color1.g, u_color1.b);
                vec3 c2 = rgb(u_color2.r, u_color2.g, u_color2.b);
                vec3 c3 = rgb(u_color3.r, u_color3.g, u_color3.b);
                vec3 color = c1;

                color = mix(color, c2, vDistortion1);
                color = mix(color, c3, vDistortion2);

                float dist = distance(vPos.xy, vec2(0.));
                float area = smoothstep((u_radius * 0.6) - (u_radius * 0.6) / 5., (u_radius * 0.6), dist);

                vec2 uv = vUv;
                uv.x = 1. - (cos(uv.x * TAU) + 1.) / 2.;

                // color = mix(color, vec3(0.), area * 1.);

                gl_FragColor = vec4(color, 1.) * addedLights;
            }
        </script>

        <script>
            var createHeroInteractive = function($container) {
                'use strict'
                // prettier-ignore
                var renderer, scene, camera, pixelRatio = Math.min(window.devicePixelRatio, 2),
                  	geometry1, material1, mesh1, backgroundScene, backgroundCamera,
                  	fov = 45;

                var mousePosition = {
                    x: 0.5,
                    y: 0.5,
                    drag: 0
                }

                var textureFlare0 = new THREE.TextureLoader().load(
                    'https://s3.amazonaws.com/jsfiddle1234/lensflare0.png'
                )

                var light = new THREE.PointLight(0xffffff, 1, 1000, 2)
                light.color.setHSL(0.88, 1, 1)
                light.position.set(0, 0, 1000)

                var start = Date.now()
                var fixedTime = 0,
                    timeOffset = 0,
                    dynamicTime = 0

                var w, h, isMobile

                var camX = 0
                var camY = 0

                var isFocused = true,
                    isInited = false,
                    inViewport = false
                window.addEventListener('blur', function() {
                    isFocused = false
                })
                window.addEventListener('focus', function() {
                    isFocused = true
                    if (isInited) {
                        render()
                    }
                })

                function updateSize() {
                    w = $container.offsetWidth
                    h = $container.offsetHeight
                    isMobile = w < 800
                }

                function addLight(scene, h, s, l, x, y, z) {
                    var light1 = new THREE.PointLight(0xffffff, 1, 1000, 2)
                    light1.color.setHSL(h, s, l)
                    light1.position.set(x, y, z)
                    var lensflare = new THREE.Lensflare()
                    lensflare.addElement(new THREE.LensflareElement(textureFlare0, 2500, 0, light1.color))
                    lensflare.addElement(new THREE.LensflareElement(textureFlare0, 60, 0.6))
                    lensflare.addElement(new THREE.LensflareElement(textureFlare0, 70, 0.7))
                    lensflare.addElement(new THREE.LensflareElement(textureFlare0, 120, 0.9))
                    lensflare.addElement(new THREE.LensflareElement(textureFlare0, 80, 1))
                    light1.add(lensflare)
                    scene.add(light1)
                }

                init()

                function init() {
                    updateSize()

                    scene = new THREE.Scene()
                    scene.fog = new THREE.Fog(scene.background, 3500, 15000)

                    camera = new THREE.PerspectiveCamera(fov, w / h, 1, 500)
                    camera.position.z = isMobile ? 200 : 150

                    var dirLight = new THREE.DirectionalLight(0xffffff, 0.05)
                    dirLight.position.set(0, -1, 0).normalize()
                    dirLight.color.setHSL(0.1, 0.7, 0.5)
                    scene.add(dirLight)

                    scene.add(camera)

                    var lightsUniform = THREE.UniformsUtils.merge([THREE.UniformsLib['lights']])

                    geometry1 = new THREE.IcosahedronGeometry(34, 6)
                    material1 = new THREE.ShaderMaterial({
                        uniforms: {
                            u_color3: { type: 'v3', value: new THREE.Vector3(0, 186, 240) },
                            u_color1: { type: 'v3', value: new THREE.Vector3(255, 0, 255) },
                            u_color2: { type: 'v3', value: new THREE.Vector3(0, 244, 255) },
                            u_time: { type: 'f', value: 0 },
                            u_timeOffset: { type: 'f', value: 4.6 },
                            lightIntensity: { type: 'f', value: 1.35 },
                            u_dimensions: {
                                type: 'v2',
                                value: new THREE.Vector2(w * pixelRatio, h * pixelRatio)
                            },
                            u_radius: { type: 'f', value: 40 },
                            ...lightsUniform
                        },
                        fragmentShader: document.querySelector('#fragmentShader2').textContent,
                        vertexShader: document.querySelector('#vertexShader2').textContent,
                        lights: true,
                        transparent: false
                    })

                    mesh1 = new THREE.Mesh(geometry1, material1)
                    mesh1.position.set(-35, 0, 0)
                    mesh1.scale.multiplyScalar(1.0)
                    mesh1.rotation.x = 0.0
                    mesh1.rotation.y = 0.0
                    mesh1.rotation.z = 1.6
                    scene.add(mesh1)

                    scene.add(light)

                    var pointColor = '#ffffff'

                    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
                    renderer.setPixelRatio(pixelRatio)
                    renderer.setSize(w, h)

                    renderer.gammaInput = true
                    renderer.gammaOutput = true

                    $container.appendChild(renderer.domElement)

                    window.addEventListener('resize', handleResize)
                    if ('ontouchstart' in window) {
                        document.body.addEventListener('touchmove', handleTouchMove)
                    } else {
                        document.body.addEventListener('mousemove', handleMouseMove)
                        document.body.addEventListener('mousedown', handleMouseDown)
                        document.body.addEventListener('mouseup', handleMouseUp)
                    }

                    isInited = true

                    var backgroundTexture = new THREE.TextureLoader().load(
                        'https://272507.selcdn.ru/evys_api_videos/bg_new.png'
                    )
                    scene.background = backgroundTexture
                    render()
                }

                function handleResize() {
                    updateSize()
                    renderer.setSize(w, h)
                    camera.aspect = w / h

                    var v2WH = new THREE.Vector2(w, h)
                    camera.updateProjectionMatrix()
                }

                function handleTouchMove(e) {
                    var touch = e.touches[0]
                    mousePosition.x = touch.pageX / w
                    mousePosition.y = touch.pageY / h
                }

                function handleMouseMove(e) {
                    if (!mousePosition.drag) return
                    mousePosition.x = e.pageX / w
                    mousePosition.y = e.pageY / h
                }

                function handleMouseDown(e) {
                    mousePosition.drag = 1
                }

                function handleMouseUp(e) {
                    mousePosition.drag = 0
                }

                function render(timestamp) {
                    if (isFocused) {
                        camX = ((mousePosition.x - 0.5) * (isMobile ? 120 : 80) - camera.position.x) * 0.05
                        camY = ((mousePosition.y - 0.5) * (isMobile ? 80 : 40) - camera.position.y) * 0.05
                        fixedTime = 0.0008 * (Date.now() - start)

                        timeOffset += (Math.abs(camX) + Math.abs(camY)) / (isMobile ? 50 : 20)
                        dynamicTime = fixedTime + timeOffset
                        material1.uniforms.u_time.value = dynamicTime

                        camera.position.x += camX
                        camera.position.y += camY
                        camera.lookAt(scene.position)

                        renderer.gammaInput = true
                        renderer.gammaOutput = true

                        renderer.render(scene, camera)
                        requestAnimationFrame(render)
                    }
                }
            }
            createHeroInteractive(document.getElementById('container'))
        </script>
    </body>
</html>
